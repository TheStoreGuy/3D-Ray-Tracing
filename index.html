<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CPU Ray Tracing — Reflective Sphere + Street Envmap (Orbit)</title>
  <style>
    :root{ --bg:#0b0e12; --panel:#12161d; --ink:#e5edff; --muted:#90a0b8; --accent:#4f46e5; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b0e12,#0a0d13 40%,#0b0e12);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Inter,sans-serif}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:18px;height:100%;padding:18px}
    @media (max-width: 900px){.wrap{grid-template-columns:1fr; grid-auto-rows:min-content 1fr}}
    .panel{background:var(--panel); border:1px solid #1f2530; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{font-size:18px;margin:0 0 8px}
    .sub{color:var(--muted);font-size:12px;margin-bottom:12px}
    .row{display:flex;align-items:center;gap:10px;margin:10px 0}
    .row label{flex:1;color:#cbd5e1}
    .row input[type=range]{flex:2}
    .row select,.row input[type=number]{flex:1;background:#0f131a;border:1px solid #273043;color:var(--ink);border-radius:10px;padding:6px}
    .row button{flex:1; padding:10px 12px; border:0;border-radius:12px; background:var(--accent); color:white; cursor:pointer}
    .row button.ghost{background:#0f131a; border:1px solid #273043}
    canvas{width:100%; height:100%; display:block; background:#070a0f; border:1px solid #1f2530; border-radius:16px; cursor:grab}
    canvas:active{cursor:grabbing}
    .badge{font-size:11px;color:#9aa9c7;background:#0f131a;border:1px solid #273043;border-radius:999px;padding:4px 8px}
    .credits{position:absolute; right:12px; bottom:12px; color:#9aa9c7; font-size:11px; background:#0b0e12cc; padding:6px 10px; border:1px solid #273043; border-radius:999px}
    .credits a{color:#cbd5e1; text-decoration:underline}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="panel">
      <h1>Ray Traced Sphere</h1>
      <div class="sub">CPU ray tracing in JS · Reflective sphere · Equirectangular street environment</div>
      <div class="row"><label>Resolution scale</label>
        <select id="scale">
          <option value="0.5">0.5× (fast)</option>
          <option value="0.75">0.75×</option>
          <option value="1" selected>1.0×</option>
          <option value="1.25">1.25×</option>
        </select>
      </div>
      <div class="row"><label>FOV</label><input id="fov" type="range" min="30" max="100" value="60"><span class="badge" id="fovOut">60°</span></div>
      <div class="row"><label>Sphere radius</label><input id="radius" type="range" min="0.3" max="1.4" step="0.01" value="0.75"><span class="badge" id="radOut">0.75</span></div>
      <div class="row"><label>Reflectivity</label><input id="refl" type="range" min="0" max="1" step="0.01" value="1"><span class="badge" id="reflOut">1.00</span></div>
      <div class="row"><label>Cam distance</label><input id="dist" type="range" min="1.2" max="8" step="0.05" value="3"><span class="badge" id="distOut">3.00</span></div>
      <div class="row"><button id="renderBtn">Render</button><button id="saveBtn" title="Save PNG" class="ghost">Save</button></div>
      <div class="sub"><b>Drag</b> on the image to orbit. <b>Scroll</b> to zoom. Click <b>Render</b> after changing settings.</div>
      <div class="sub">Envmap source: Wikimedia Commons (CC BY 4.0). Attribution below.</div>
    </aside>
    <main class="panel" style="position:relative; overflow:hidden">
      <canvas id="view"></canvas>
      <div class="credits">Envmap: <a href="https://commons.wikimedia.org/wiki/File:Wisconsin_Ave_and_Woodmont_Ave_360_panorama_Bethesda_MD_2025-07-27_09-56-34_1.jpg" target="_blank" rel="noopener">Bethesda Street 360°</a> by G. Edward Johnson (CC BY 4.0)</div>
    </main>
  </div>

  <script>
  (()=>{
    // Keep original functionality (render button, sliders) and ADD orbit + zoom controls

    const ENVMAP_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Wisconsin_Ave_and_Woodmont_Ave_360_panorama_Bethesda_MD_2025-07-27_09-56-34_1.jpg/2560px-Wisconsin_Ave_and_Woodmont_Ave_360_panorama_Bethesda_MD_2025-07-27_09-56-34_1.jpg';

    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));

    // UI
    const $ = id=>document.getElementById(id);
    const fovEl = $('fov'), scaleEl = $('scale'), radEl=$('radius'), reflEl=$('refl'), distEl=$('dist');
    const fovOut=$('fovOut'), radOut=$('radOut'), reflOut=$('reflOut'), distOut=$('distOut');
    const renderBtn = $('renderBtn'), saveBtn=$('saveBtn');

    function syncLabels(){
      fovOut.textContent = fovEl.value + '°';
      radOut.textContent = (+radEl.value).toFixed(2);
      reflOut.textContent = (+reflEl.value).toFixed(2);
      distOut.textContent = (+distEl.value).toFixed(2);
    }
    ['input','change'].forEach(ev=>{ fovEl.addEventListener(ev,syncLabels); radEl.addEventListener(ev,syncLabels); reflEl.addEventListener(ev,syncLabels); distEl.addEventListener(ev,syncLabels); });
    syncLabels();

    // Resize
    function resize(){
      const r = canvas.parentElement.getBoundingClientRect();
      const scale = parseFloat(scaleEl.value);
      canvas.width = Math.max(1, Math.floor(r.width * DPR * scale));
      canvas.height = Math.max(1, Math.floor(r.height * DPR * scale));
      ctx.setTransform(1,0,0,1,0,0);
    }
    window.addEventListener('resize', ()=>{ resize(); render(); });

    // Load envmap
    const envImg = new Image(); envImg.crossOrigin = 'anonymous'; envImg.src = ENVMAP_URL;
    const env = { ready:false, w:0,h:0, data:null };
    envImg.onload = ()=>{
      const oc = document.createElement('canvas'); oc.width = envImg.width; oc.height = envImg.height;
      const octx = oc.getContext('2d'); octx.drawImage(envImg,0,0);
      const img = octx.getImageData(0,0,oc.width,oc.height);
      env.ready = true; env.w = oc.width; env.h = oc.height; env.data = img.data;
      resize(); render();
    };

    // Math helpers
    const V = {
      dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
      add:(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
      sub:(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
      mul:(a,s)=>[a[0]*s,a[1]*s,a[2]*s],
      norm:(a)=>{ const l=Math.hypot(a[0],a[1],a[2])||1e-8; return [a[0]/l,a[1]/l,a[2]/l]; },
      cross:(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]
    };

    function clamp(x,a,b){ return x<a?a:(x>b?b:x); }

    // Envmap sampling
    function dirToUV(d){
      const lon = Math.atan2(d[0], -d[2]);
      const lat = Math.asin( clamp(d[1], -1, 1) );
      let u = (lon + Math.PI) / (2*Math.PI);
      let v = (lat + Math.PI/2) / Math.PI;
      u = (u % 1 + 1) % 1; v = Math.min(0.999999, Math.max(0, v));
      return [u, v];
    }
    function sampleEnv(d){
      if(!env.ready) return [30,34,40];
      const uv = dirToUV(d);
      const x = Math.floor(uv[0] * env.w);
      const y = Math.floor((1-uv[1]) * env.h);
      const idx = ((y*env.w + x) | 0) * 4;
      return [env.data[idx], env.data[idx+1], env.data[idx+2]];
    }

    // Ray-sphere intersection
    function hitSphere(ro, rd, radius){
      const b = V.dot(ro, rd);
      const c = V.dot(ro, ro) - radius*radius;
      const disc = b*b - c;
      if(disc < 0) return null;
      const t = -b - Math.sqrt(disc);
      if(t <= 0) return null;
      return t;
    }

    // Camera state (orbit around origin)
    const cam = { yaw: 0, pitch: 0, dist: +distEl.value };
    function camPos(){
      const cy = Math.sin(cam.pitch);
      const cp = Math.cos(cam.pitch);
      const sx = Math.sin(cam.yaw), cx = Math.cos(cam.yaw);
      const x = cam.dist * sx * cp;
      const y = cam.dist * cy;
      const z = cam.dist * cx * cp;
      return [x,y,z];
    }

    function buildCameraBasis(pos){
      // Look at origin; forward points from camera to origin
      const f = V.norm(V.mul(pos, -1));
      let upWorld = Math.abs(f[1])>0.99? [0,0,1] : [0,1,0];
      const r = V.norm(V.cross(f, upWorld));
      const u = V.norm(V.cross(r, f));
      return {f,r,u};
    }

    // Rendering
    function render(){
      if(!env.ready){ ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      const w = canvas.width, h = canvas.height;
      const img = ctx.createImageData(w,h);
      const data = img.data;

      const fov = (+fovEl.value) * Math.PI/180;
      const tanHalf = Math.tan(fov*0.5);
      cam.dist = +distEl.value; // sync in case slider moved

      const pos = camPos();
      const {f,r,u} = buildCameraBasis(pos);
      const sphereR = +radEl.value;
      const reflectivity = +reflEl.value;

      let ptr = 0;
      for(let y=0;y<h;y++){
        const sy = (1 - 2*((y+0.5)/h)) * tanHalf;
        for(let x=0;x<w;x++){
          const sx = (2*((x+0.5)/w) - 1) * tanHalf * (w/h);
          // Ray dir in world from camera basis
          let rd = V.norm(V.add(f, V.add(V.mul(r, sx), V.mul(u, sy))));

          const t = hitSphere(pos, rd, sphereR);
          let col;
          if(t){
            const p = V.add(pos, V.mul(rd, t));
            const n = V.norm(p);
            const rdir = V.sub(rd, V.mul(n, 2*V.dot(rd,n)));
            const envCol = sampleEnv(rdir);
            const bgCol  = sampleEnv(rd);
            col = [
              envCol[0]*reflectivity + bgCol[0]*(1-reflectivity),
              envCol[1]*reflectivity + bgCol[1]*(1-reflectivity),
              envCol[2]*reflectivity + bgCol[2]*(1-reflectivity)
            ];
          } else {
            col = sampleEnv(rd);
          }
          data[ptr++] = col[0];
          data[ptr++] = col[1];
          data[ptr++] = col[2];
          data[ptr++] = 255;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    renderBtn.addEventListener('click', ()=>{ resize(); render(); });
    saveBtn.addEventListener('click', ()=>{
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url; a.download='raytraced_sphere.png'; a.click();
    });

    // Orbit + zoom controls (added without removing original behavior)
    let dragging=false, lastX=0, lastY=0;
    canvas.addEventListener('mousedown', (e)=>{ if(e.button===0){ dragging=true; lastX=e.clientX; lastY=e.clientY; } });
    window.addEventListener('mouseup', ()=>{ dragging=false; });
    window.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - lastX; const dy = e.clientY - lastY; lastX=e.clientX; lastY=e.clientY;
      cam.yaw += dx * 0.005;
      cam.pitch = clamp(cam.pitch + dy * 0.005, -1.25, 1.25);
      render();
    });
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      distEl.value = clamp(+distEl.value + delta*0.25, +distEl.min, +distEl.max);
      syncLabels();
      render();
    }, {passive:false});

    // First layout
    resize();

    // ——— Self-tests ———
    function approx(a,b,eps=1e-6){ return Math.abs(a-b) < eps; }
    (function runTests(){
      let pass=0, fail=0; const T=(name,fn)=>{try{fn();console.log('✅',name);pass++;}catch(e){console.error('❌',name,e);fail++;}};
      T('dirToUV range', ()=>{
        const uv = dirToUV([0,0,-1]); if(!(uv[0]>=0&&uv[0]<=1&&uv[1]>=0&&uv[1]<=1)) throw 'uv out of range';
      });
      T('camera basis orthonormal-ish', ()=>{
        const {f,r,u} = buildCameraBasis([0,0,3]);
        const fr=V.dot(f,r), fu=V.dot(f,u), ru=V.dot(r,u);
        if(!(Math.abs(fr)<1e-3 && Math.abs(fu)<1e-3 && Math.abs(ru)<1e-3)) throw 'basis not orthogonal';
      });
      console.log(`Tests complete: ${pass} passed, ${fail} failed`);
    })();

  })();
  </script>
</body>
</html>
